const apiHost = "api.sanity.io";
const cdnHost = "apicdn.sanity.io";
const enc = encodeURIComponent;
function getQuery(query, params = {}) {
  const baseQs = `?query=${enc(query)}`;
  return Object.keys(params).reduce((current, param) => {
    return `${current}&${enc(`$${param}`)}=${enc(JSON.stringify(params[param]))}`;
  }, baseQs);
}
const getByteSize = (query) => encodeURI(query).split(/%..|./).length;
function createClient(config) {
  const {
    useCdn,
    projectId,
    dataset,
    apiVersion = "1",
    withCredentials,
    token
  } = config;
  const fetchOptions = {
    credentials: withCredentials ? "include" : "omit",
    headers: {
      ...token ? {
        Authorization: `Bearer ${token}`
      } : {},
      Accept: "application/json",
      ...process.server ? { "accept-encoding": "gzip, deflate" } : {}
    }
  };
  return {
    clone: () => createClient({
      useCdn,
      projectId,
      dataset,
      apiVersion,
      withCredentials,
      token
    }),
    async fetch(query, params) {
      const qs = getQuery(query, params);
      const usePostRequest = getByteSize(qs) > 9e3;
      const host = useCdn && !usePostRequest ? cdnHost : apiHost;
      const urlBase = `https://${projectId}.${host}/v${apiVersion}/data/query/${dataset}`;
      const response = usePostRequest ? await fetch(urlBase, {
        method: "post",
        body: JSON.stringify({ query, params }),
        ...fetchOptions,
        headers: {
          ...fetchOptions.headers,
          "Content-Type": "application/json"
        }
      }) : await fetch(`${urlBase}${qs}`, fetchOptions);
      const { result } = await response.json();
      return result;
    }
  };
}

const groq = String.raw || ((strings, ...keys) => {
  const lastIndex = strings.length - 1;
  return strings.slice(0, lastIndex).reduce((query, currentString, index) => query + currentString + keys[index], "") + strings[lastIndex];
});

export { createClient, getByteSize, getQuery, groq };
